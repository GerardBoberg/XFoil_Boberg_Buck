%% Aero 306 XFoil Project
% Gerard Boberg and Trevor Buck and Zane Patterson
%
% 2 Dec 2014
function [ lambda, Cl, Cm_le, Cm_c4, Cp_dist ] = vortex_panel_analysis(...
    panels_x, panels_y, alpha, coloc_percent, kutta_drop, finite_end )
%VORTEX_PANEL_ANALYSIS does a complete vortex panel analysis
%   Takes in an airfoil, as generated by NACA4, and uses a vortex-panel
%   analysis in order to determine flight characteristics
%
%   INPUTS
%
%   panels_x : the x-nodes of the airfoil's outline
%   panels_y : the y-nodes of the airfoil's outline
%   alpha    : AoA
%   percent  : where on each panel to place the colocation point
%   kutta_drop : true to drop a row, false to least-squares reduction%
%
%   OUTPUTS
%
%   lambda : array of panel strengths
%   Cl     : Coefficient of lift
%   Cm_le  : Coefficient of moment about the leading edge
%   Cm_c4  : Coefficient of moment about the quarter-chord location
%   Cp_dist: Distribution of Coefficient of Pressure across the panels
%

if (nargin < 3)
    alpha = 0;
end
if (nargin < 4)
    coloc_percent = 0.5;
end
if (nargin < 5)
    kutta_drop = false;
end
if (nargin < 6)
    finite_end = false;
end


n_panels = length( panels_x ) - 1; % n_panels = 2 * n_foil - 2; always even

% get co-location points
panel_dx = panels_x(2:end) - panels_x(1:end-1); % one shorter than panels_x
panel_dy = panels_y(2:end) - panels_y(1:end-1);

coloc_x = panels_x( 1:n_panels ) + coloc_percent * panel_dx;  
coloc_y = panels_y( 1:n_panels ) + coloc_percent * panel_dy;
    
panel_lengths = sqrt( panel_dx.^2 + panel_dy.^2 );

% get normal vectors
norm_x = -panel_dy ./ panel_lengths;
norm_y =  panel_dx ./ panel_lengths;

%% Calculate Induced Velocities
% Calculate the A matrix
A = zeros( n_panels, n_panels );  % pre-allocate

for ii = 1:n_panels     % colocation points
    for jj = 1:n_panels % vortex panels
        x  = panels_x( jj:jj+1 );   % the jth vortex panel's induction on 
        y  = panels_y( jj:jj+1 );   % the ith colocation point
  [ dux, dvy ] = line_vortex_constant_2d( 1, x, y, coloc_x(ii), coloc_y(ii) );
        
                                    % dotted with the colocation's normal
        A( ii, jj ) = ( dux * norm_x(ii) ) + ( dvy * norm_y(ii) );
        
        
        if( (ii == ((n_panels-1)/2)) && finite_end )
        % also handle replacing the row for a finite end with a | panel 
        %   that is purely normal -- use a cross product
            A( ii, jj ) = ( dux * norm_y(ii) ) - ( dvy * norm_x(ii) );
        end
    end
end

% Calculate the b matrix, u_bar
% u_vector = < cos, sin > dot norm_vector
% transposed to make it tall. 
u_bar = transpose( (cos( alpha ) .* norm_x ) + ( sin( alpha ) .* norm_y ) );
if( finite_end )
    u_bar( (n_panels-1)/2 ) = cos( alpha ) * norm_y( (n_panels-1)/2 )...
                            - sin( alpha ) * norm_x( (n_panels-1)/2 );
end

%% Handle the Kutta Condition
% Create the row to add or swap into A
new_row = zeros( 1, n_panels ); % long vector

if( finite_end )  % odd number, want \ and / panels, not the | inbetween
    new_row( (n_panels-1)/2 - 1 ) = 1;
    new_row( (n_panels-1)/2 + 1 ) = 1;
    
    trailing_row         = zeros( 1, n_panels );
    trailing_row( (n_panels-1)/2 ) = 1;
    A( end+1, :  ) = trailing_row;
    u_bar( end+1 ) = 0;
else
    new_row( n_panels/2 + 0 ) = 1;  % even number, point end.
    new_row( n_panels/2 + 1 ) = 1;
end

if( kutta_drop )   % if true, drop a row. Else, add without dropping
    % drop the bottom of the middle panel
    index_to_drop = ceil( n_panels * 3/4 ) ;
    
    A( index_to_drop, : )  = new_row;
    u_bar( index_to_drop ) = 0;
else
    % simply add the row on. MATLAB will automatically do a least-squares
    %    approximation to deal with the imbalanced inverse
    A    ( end + 1, : ) = new_row;
    u_bar( end + 1    ) = 0;
end


%% Calculate the lambda array -- the strength of the vortex panels
% 0        = (A * lambda) dot normals + u_bar dot normals
% 0       = _A_ * lambda + _U_BAR_
% -U_BAR  = _A_ * lambda
% A^-1 * -U_BAR = lambda
% A \ -U_BAR    = lambda
lambda = A \ ( -u_bar );

%% Calculate the performance characteristics

% coefficient of lift
chord_length = 1;
Cl_per_panel = 2 * lambda .* transpose(panel_lengths);
Cl           = sum( Cl_per_panel );

% coefficient of pressure
% Cp_per_panel = 1 - ( u / u_inf )^2
Cp_dist    = 1:n_panels; % pre-allocate
U_inf = 1;

% For each colocation point, find the total Ux and Vy velocity components
%    We do this by totaling the induced velocity at that point:
%    the free stream, < cos, sin >, + for-each of the vortex panels
for ii = 1:n_panels      % ith colocation point
    Ux = U_inf * cos( alpha );
    Vy = U_inf * sin( alpha );
    for jj = 1:n_panels  % jth vortex panel
        x  = panels_x( jj:jj+1 );   % the jth vortex panel's induction on 
        y  = panels_y( jj:jj+1 );   % the ith colocation point
        [ dux, dvy ] = line_vortex_constant_2d( lambda(jj) , x, y,...
                                            coloc_x(ii), coloc_y(ii) );
        Ux = Ux + dux;
        Vy = Vy + dvy;
    end
    U             = sqrt( Ux^2 + Vy^2 );
    Cp_dist( ii ) = 1 - ( U / U_inf )^2;
end

% coefficient of moment
Cm_le = 0; % pre-allocate
Cm_c4 = 0;

le_x = 0; % coords of leading edge
le_y = 0;

c4_x = 0.25; % coords of 1/4 chord length -- NOT CAMBER
c4_y = 0;

for ii = 1:n_panels    % ith colocation point
    % moment = sum of F cross R
    % Coef Moment = Sum of Coef Force cross R / c
    r_x = coloc_x(ii) - le_x;
    r_y = coloc_y(ii) - le_y;
    % r = r / chord_length;   % chord length = 1
    
    % r cross norm = rx * norm_y - ry * norm_x
    Cm_le = Cm_le + Cl_per_panel(ii) *...
        ( r_x * norm_y(ii) - r_y * norm_x(ii) );
    
    r_x = coloc_x(ii) - c4_x;
    r_y = coloc_y(ii) - c4_y;
    % r = r / chord_length
    
    % r cross norm = rx * norm_y - ry * norm_x
    Cm_c4 = Cm_c4 + Cl_per_panel(ii) *...
        ( r_x * norm_y(ii) - r_y * norm_x(ii) );
    
end


% Aerospace moments are left-hand rule, so just negate the result.
Cm_le = Cm_le / chord_length;
Cm_c4 = Cm_c4 / chord_length;


end % End of File

